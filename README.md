
# ä¸­æ–‡ç‰ˆ (Chinese Version)

# å®éªŒæµä½“ç²¾å¯†æ§åˆ¶ç³»ç»Ÿ

è¿™æ˜¯ä¸€ä¸ªä¸ºåŒ–å­¦æˆ–ææ–™ç§‘å­¦å®éªŒè®¾è®¡çš„è‡ªåŠ¨åŒ–æµä½“ç²¾å¯†æ§åˆ¶ç³»ç»Ÿã€‚å®ƒæä¾›äº†ä¸€ä¸ªå›¾å½¢ç”¨æˆ·ç•Œé¢ï¼ˆGUIï¼‰ï¼Œç”¨äºå®æ—¶ç›‘æ§å’Œæ§åˆ¶å¤šä¸ªè •åŠ¨æ³µã€æŸ±å¡æ³µä»¥åŠå¤šé€šé“ç›´æµç”µæºï¼Œå¹¶æ”¯æŒè‡ªåŠ¨åŒ–å®éªŒæµç¨‹åè®®ã€‚

 \#\# âœ¨ åŠŸèƒ½ç‰¹æ€§

  * **å›¾å½¢åŒ–ç•Œé¢**: åŸºäº PyQt6 æ„å»ºï¼Œç›´è§‚æ˜“ç”¨ï¼Œæä¾›ä¸»å¯åŠ¨å™¨ã€åˆ†ç³»ç»Ÿæ§åˆ¶å’Œç‹¬ç«‹è®¾å¤‡è°ƒè¯•ä¸‰ç§çª—å£æ¨¡å¼ã€‚
  * **å¤šè¿›ç¨‹æ¶æ„**: ä¸»ç•Œé¢ï¼ˆUIï¼‰ä¸è®¾å¤‡æ§åˆ¶åå°ï¼ˆControllerï¼‰åœ¨ä¸åŒè¿›ç¨‹ä¸­è¿è¡Œï¼Œç¡®ä¿äº†ç•Œé¢çš„æµç•…å“åº”ï¼Œå³ä½¿åœ¨è®¾å¤‡é€šä¿¡ç¹å¿™æ—¶ä¹Ÿä¸ä¼šå¡é¡¿ã€‚
  * **å®æ—¶æ•°æ®ç›‘æ§**: ä½¿ç”¨ `pyqtgraph` å®æ—¶ç»˜åˆ¶å„è®¾å¤‡ï¼ˆå¦‚ç”µæºç”µå‹ã€ç”µæµï¼Œæ³µçš„è½¬é€Ÿã€æµé‡ï¼‰çš„çŠ¶æ€æ›²çº¿ï¼Œä¸€ç›®äº†ç„¶ã€‚
  * **è‡ªåŠ¨åŒ–åè®®**: æ”¯æŒåˆ›å»ºã€ç¼–è¾‘ã€ä¿å­˜å’ŒåŠ è½½è‡ªåŠ¨åŒ–å®éªŒæµç¨‹ã€‚æ‚¨å¯ä»¥å°†ä¸€ç³»åˆ—æ“ä½œï¼ˆå¦‚å¯åœæ³µã€è®¾ç½®å‚æ•°ã€å»¶æ—¶ï¼‰ç»„åˆæˆä¸€ä¸ªåè®®å¹¶ä¸€é”®æ‰§è¡Œã€‚
  * **çµæ´»çš„é…ç½®ç³»ç»Ÿ**:
      * æ‰€æœ‰ç¡¬ä»¶é…ç½®ï¼ˆCOM ç«¯å£ã€è®¾å¤‡åœ°å€ç­‰ï¼‰éƒ½å­˜å‚¨åœ¨å¤–éƒ¨ `system_config.json` æ–‡ä»¶ä¸­ï¼Œæ— éœ€ä¿®æ”¹ä»£ç å³å¯è½»æ¾é€‚é…ä¸åŒçš„ç¡¬ä»¶è¿æ¥ã€‚
      * å¯åŠ¨å™¨ç•Œé¢å†…ç½®äº†é…ç½®ç¼–è¾‘å™¨ï¼Œå¯ä»¥ç›´æ¥åœ¨å›¾å½¢ç•Œé¢ä¸Šä¿®æ”¹å¹¶ä¿å­˜ç¡¬ä»¶å‚æ•°ã€‚
  * **æ¨¡å—åŒ–è®¾å¤‡é©±åŠ¨**: æ¯ç§è®¾å¤‡ï¼ˆä¸åŒå‹å·çš„æ³µã€ç”µæºï¼‰éƒ½æœ‰ç‹¬ç«‹çš„æ§åˆ¶å™¨æ–‡ä»¶ï¼ŒåŸºäºç»Ÿä¸€çš„åŸºç±»æ¥å£å®ç°ï¼Œæ˜“äºæ‰©å±•å’Œç»´æŠ¤ã€‚
  * **ä¸€é”®æ‰“åŒ…**: æä¾› `build.bat` è„šæœ¬ï¼Œå¯ä½¿ç”¨ PyInstaller å°†æ•´ä¸ªé¡¹ç›®æ‰“åŒ…æˆç‹¬ç«‹çš„ `.exe` å¯æ‰§è¡Œæ–‡ä»¶ï¼Œæ–¹ä¾¿åœ¨ä»»ä½• Windows ç”µè„‘ä¸Šéƒ¨ç½²å’Œè¿è¡Œã€‚

## ğŸ“ ç³»ç»Ÿæ¶æ„

ç³»ç»Ÿé‡‡ç”¨ç»å…¸çš„å¤šè¿›ç¨‹ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å‹ï¼Œå°†å‰ç«¯ UI å’Œåç«¯è®¾å¤‡æ§åˆ¶è§£è€¦ã€‚

```
+--------------------------+      (multiprocessing.Queue)      +-----------------------------+
|        ä¸»è¿›ç¨‹ (UI)       |         Command & Status         |      åå°å­è¿›ç¨‹ (Controller)    |
|       (main.py)          |                                  |   (system_controller.py)    |
|                          |                                  |                             |
| +----------------------+ |         [ç”¨æˆ·æŒ‡ä»¤]                  | +-------------------------+   |
| |  Launcher/Control  | |  ---------------------------->   | |     Command Processor   |   |
| |      Windows       | |                                  | | (å¤„ç†UIå‘æ¥çš„æŒ‡ä»¤)      |   |
| +----------------------+ |         [è®¾å¤‡çŠ¶æ€]                  | +-------------------------+   |
| |   Real-time Plots  | |  <----------------------------   | |      Status Poller      |   |
| |   (æ•°æ®å¯è§†åŒ–)     | |                                  | | (è½®è¯¢æ‰€æœ‰è®¾å¤‡çŠ¶æ€)      |   |
| +----------------------+ |                                  | +-------------------------+   |
|                          |                                  | |     Device Drivers      |   |
|                          |                                  | | (ä¸çœŸå®ç¡¬ä»¶é€šä¿¡)        |   |
|                          |                                  | +--+-----------+--------+   |
+--------------------------+                                  +----|---(PyVISA)---|--------+---+
                                                                   |              |
                                                              +----v----+    +-----v-----+
                                                              |  ç”µæº   |    |    æ³µ     |
                                                              +---------+    +-----------+
```

1.  **UI è¿›ç¨‹ (`main.py`)**: è´Ÿè´£æ‰€æœ‰ç”¨æˆ·äº¤äº’ã€‚å½“ç”¨æˆ·ç‚¹å‡»æŒ‰é’®ï¼ˆå¦‚â€œå¯åŠ¨æ³µâ€ï¼‰æ—¶ï¼Œå®ƒä¼šå°†ä¸€ä¸ªæŒ‡ä»¤ï¼ˆå¦‚ `{'type': 'start_pump', 'params': ...}`ï¼‰æ”¾å…¥**æŒ‡ä»¤é˜Ÿåˆ— (Command Queue)**ã€‚åŒæ—¶ï¼Œå®ƒä¼šæŒç»­ä»**çŠ¶æ€é˜Ÿåˆ— (Status Queue)** ä¸­è·å–æœ€æ–°çš„è®¾å¤‡æ•°æ®æ¥æ›´æ–°å›¾è¡¨å’ŒçŠ¶æ€æ ‡ç­¾ã€‚
2.  **Controller è¿›ç¨‹ (`system_controller.py`)**:
      * å¯åŠ¨åï¼Œæ ¹æ®é…ç½®åˆå§‹åŒ–å¹¶è¿æ¥æ‰€æœ‰ç¡¬ä»¶è®¾å¤‡ã€‚
      * åœ¨ä¸€ä¸ªå¾ªç¯ä¸­ï¼Œå®ƒä¸æ–­åœ°æ£€æŸ¥æŒ‡ä»¤é˜Ÿåˆ—ã€‚ä¸€æ—¦æ”¶åˆ°æŒ‡ä»¤ï¼Œå°±è°ƒç”¨ç›¸åº”çš„è®¾å¤‡é©±åŠ¨æ‰§è¡Œæ“ä½œï¼ˆå¦‚é€šè¿‡ `pymodbus` æˆ– `pyvisa` å‘é€ä¸²å£å‘½ä»¤ï¼‰ã€‚
      * å®ƒä¼šå®šæœŸï¼ˆä¾‹å¦‚æ¯ç§’ï¼‰è½®è¯¢æ‰€æœ‰è®¾å¤‡çš„å½“å‰çŠ¶æ€ï¼ˆç”µå‹ã€æ˜¯å¦åœ¨è¿è¡Œç­‰ï¼‰ï¼Œå¹¶å°†è¿™äº›çŠ¶æ€æ‰“åŒ…æ”¾å…¥çŠ¶æ€é˜Ÿåˆ—ï¼Œä¾› UI è¿›ç¨‹æ¶ˆè´¹ã€‚

è¿™ç§è®¾è®¡ç¡®ä¿äº† I/O å¯†é›†å‹çš„ç¡¬ä»¶é€šä¿¡ä¸ä¼šé˜»å¡ç”¨æˆ·ç•Œé¢çš„æ“ä½œã€‚

## ğŸ“‚ æ–‡ä»¶ç»“æ„

```
/
â”œâ”€â”€ main.py                     # GUIä¸»ç¨‹åºå…¥å£ï¼ŒåŒ…å«æ‰€æœ‰çª—å£å’ŒUIé€»è¾‘
â”œâ”€â”€ system_controller.py        # åå°è®¾å¤‡æ§åˆ¶æ ¸å¿ƒé€»è¾‘
â”œâ”€â”€ config.py                   # é…ç½®æ–‡ä»¶åŠ è½½ä¸ä¿å­˜é€»è¾‘
â”œâ”€â”€ system_config.json          # ã€é‡è¦ã€‘ç”¨æˆ·ç¡¬ä»¶é…ç½®æ–‡ä»¶
â”œâ”€â”€ system_config.py            # é»˜è®¤çš„ç¡¬ä»¶é…ç½® (ä½œä¸ºå¤‡ä»½)
|
â”œâ”€â”€ base_pump.py                # æ³µè®¾å¤‡çš„æŠ½è±¡åŸºç±»ï¼Œå®šä¹‰é€šç”¨æ¥å£
â”œâ”€â”€ kamoer_pump_controller.py   # å¡è«å°”è •åŠ¨æ³µçš„å…·ä½“å®ç°
â”œâ”€â”€ plunger_pump_controller.py  # æ¬§ä¸–ç››æŸ±å¡æ³µçš„å…·ä½“å®ç°
â”œâ”€â”€ power_supply_controller.py  # å›ºçº¬GPDç³»åˆ—ç”µæºçš„å…·ä½“å®ç°
|
â”œâ”€â”€ requirements.txt            # é¡¹ç›®ä¾èµ–åº“åˆ—è¡¨
â”œâ”€â”€ build.bat                   # ä¸€é”®æ‰“åŒ…æˆEXEçš„æ‰¹å¤„ç†è„šæœ¬
â”œâ”€â”€ build.spec                  # PyInstallerçš„é…ç½®æ–‡ä»¶
â”œâ”€â”€ address.py                  # ç”¨äºä¿®æ”¹æ³µåœ°å€çš„ç‹¬ç«‹å·¥å…·è„šæœ¬
â””â”€â”€ èµ„æºæŒ‡å—.md                 # å…³äºå¦‚ä½•æ‰“åŒ…çš„è¯¦ç»†ä¸­æ–‡è¯´æ˜
```

## ğŸš€ å¦‚ä½•è¿è¡Œ

### 1\. ç¯å¢ƒå‡†å¤‡

  * **Python**: ç¡®ä¿æ‚¨å·²å®‰è£… Python 3.8 æˆ–æ›´é«˜ç‰ˆæœ¬ã€‚
  * **å…‹éš†ä»“åº“**: `git clone https://github.com/Shirley-Sun-222/multi-processing-system.git`
  * **å®‰è£…ä¾èµ–**: å¼ºçƒˆå»ºè®®åœ¨è™šæ‹Ÿç¯å¢ƒä¸­è¿›è¡Œã€‚
    ```bash
    # åˆ›å»ºå¹¶æ¿€æ´»è™šæ‹Ÿç¯å¢ƒ (å¯é€‰ä½†æ¨è)
    python -m venv venv
    source venv/bin/activate  # on Windows: venv\Scripts\activate
    
    # å®‰è£…æ‰€æœ‰å¿…è¦çš„åº“
    pip install -r requirements.txt
    ```

### 2\. ç¡¬ä»¶é…ç½®

è¿™æ˜¯æœ€å…³é”®çš„ä¸€æ­¥ã€‚

1.  æ‰“å¼€ `system_config.json` æ–‡ä»¶ã€‚
2.  æ ¹æ®æ‚¨çš„å®é™…ç¡¬ä»¶è¿æ¥æƒ…å†µï¼Œä¿®æ”¹æ¯ä¸ªè®¾å¤‡çš„ `port` å’Œ `address`ã€‚
      * å¯¹äºç”µæºï¼Œ`port` é€šå¸¸æ˜¯ `ASRL6::INSTR` è¿™æ ·çš„ VISA èµ„æºåã€‚
      * å¯¹äºæ³µï¼Œ`port` æ˜¯ COM ç«¯å£å·ï¼ˆå¦‚ `COM9`ï¼‰ï¼Œ`address` æ˜¯å…¶ Modbus åœ°å€ã€‚
      * ç¡®ä¿æ¯ä¸ªè®¾å¤‡çš„ `id` éƒ½æ˜¯å”¯ä¸€çš„ã€‚

### 3\. ä»æºç è¿è¡Œ

å®Œæˆé…ç½®åï¼Œåœ¨é¡¹ç›®æ ¹ç›®å½•è¿è¡Œä¸»ç¨‹åºï¼š

```bash
python main.py
```

ç¨‹åºä¼šé¦–å…ˆæ˜¾ç¤ºä¸€ä¸ªå¯åŠ¨å™¨çª—å£ï¼Œæ‚¨å¯ä»¥ä»ä¸­é€‰æ‹©è¦æ§åˆ¶çš„ç³»ç»Ÿæˆ–è°ƒè¯•å•ä¸ªè®¾å¤‡ã€‚

### 4\. æ‰“åŒ…æˆ EXE æ–‡ä»¶è¿è¡Œ

å¦‚æœæ‚¨æƒ³åœ¨æ²¡æœ‰å®‰è£… Python ç¯å¢ƒçš„ç”µè„‘ä¸Šè¿è¡Œï¼Œå¯ä»¥å°†å…¶æ‰“åŒ…æˆ `.exe` æ–‡ä»¶ã€‚

1.  ç¡®ä¿é¡¹ç›®æ ¹ç›®å½•ä¸‹æœ‰ `build.bat` å’Œ `build.spec` æ–‡ä»¶ã€‚
2.  **åŒå‡»è¿è¡Œ `build.bat` è„šæœ¬**ã€‚
3.  è„šæœ¬ä¼šè‡ªåŠ¨å®‰è£… `pyinstaller` å¹¶æ‰§è¡Œæ‰“åŒ…å‘½ä»¤ã€‚
4.  ç­‰å¾…æ‰“åŒ…è¿‡ç¨‹å®Œæˆã€‚æˆåŠŸåï¼Œæ‚¨ä¼šåœ¨é¡¹ç›®ç›®å½•ä¸‹çœ‹åˆ°ä¸€ä¸ª `dist` æ–‡ä»¶å¤¹ã€‚
5.  è¿›å…¥ `dist` æ–‡ä»¶å¤¹ï¼Œæ‰¾åˆ° `æ§åˆ¶ç³»ç»Ÿ.exe`ï¼Œè¿™å°±æ˜¯æ‚¨çš„ç‹¬ç«‹åº”ç”¨ç¨‹åºã€‚ç›´æ¥åŒå‡»å³å¯è¿è¡Œã€‚

## ğŸ“– æ“ä½œæŒ‡å—

1.  **å¯åŠ¨å™¨**:

      * ç¨‹åºå¯åŠ¨åé¦–å…ˆçœ‹åˆ°çš„æ˜¯å¯åŠ¨å™¨çª—å£ã€‚
      * ç‚¹å‡» **â€œå¯åŠ¨ æ§åˆ¶ç”µæºç³»ç»Ÿ Xâ€** æŒ‰é’®æ¥æ‰“å¼€å¯¹åº”ç³»ç»Ÿçš„å®Œæ•´æ§åˆ¶ç•Œé¢ã€‚
      * ç‚¹å‡» **â€œè°ƒè¯•å•ä¸ªè®¾å¤‡â€** æŒ‰é’®ï¼Œå¯ä»¥é€‰æ‹©ä¸€ä¸ªè®¾å¤‡ï¼ˆå¦‚æŸä¸ªæ³µæˆ–ç”µæºï¼‰è¿›å…¥ä¸“é—¨çš„è°ƒè¯•çª—å£ï¼Œè¿›è¡Œç‹¬ç«‹æ“ä½œå’Œæµ‹è¯•ã€‚
      * å±•å¼€ **â€œç¡¬ä»¶é…ç½®â€** é¢æ¿ï¼Œå¯ä»¥ç›´æ¥ä¿®æ”¹è®¾å¤‡çš„ç«¯å£å’Œåœ°å€ï¼Œç‚¹å‡»å³ä¸‹è§’çš„ **â€œä¿å­˜æ‰€æœ‰é…ç½®â€** æŒ‰é’®å³å¯å°†æ›´æ”¹å†™å…¥ `system_config.json` æ–‡ä»¶ã€‚

    <img src=image/ä¸»ç•Œé¢.png alt="ä¸»ç•Œé¢" style="zoom:50%" />

2.  **ç³»ç»Ÿæ§åˆ¶çª—å£**:

      * ç•Œé¢åˆ†ä¸ºå·¦å³ä¸¤ä¸ªå­ç³»ç»Ÿï¼ˆA å’Œ Bï¼‰ï¼Œåˆ†åˆ«å¯¹åº”ç”µæºçš„ä¸¤ä¸ªé€šé“ã€‚
      * **ç”µæºæ§åˆ¶**: å¯ä»¥è®¾ç½®ç›®æ ‡ç”µå‹ã€ç”µæµï¼Œå¹¶ç‹¬ç«‹å¼€å…³æ¯ä¸ªé€šé“çš„è¾“å‡ºã€‚æ”¯æŒå®šæ—¶å…³é—­åŠŸèƒ½ã€‚
      * **æ³µæ§åˆ¶**: å¯¹äºæ¯ä¸ªæ³µï¼Œå¯ä»¥è®¾ç½®å…¶å‚æ•°ï¼ˆè½¬é€Ÿ/æµé‡ï¼‰ï¼Œé€‰æ‹©æ–¹å‘ï¼Œå¹¶å•ç‹¬å¯åŠ¨æˆ–åœæ­¢ã€‚
      * **å®æ—¶å›¾è¡¨**: ä¸‹æ–¹å›¾è¡¨ä¼šå®æ—¶æ˜¾ç¤ºç”µå‹ã€ç”µæµå’Œæ³µçš„è¿è¡Œå‚æ•°ã€‚å¯ä»¥å¯¼å‡ºå›¾è¡¨ä¸ºå›¾ç‰‡æˆ–å°†æ•°æ®å¯¼å‡ºä¸º Excelã€‚
      * **åè®®ç¼–è¾‘å™¨**:
          * ç‚¹å‡»â€œå¯åŠ¨/è®¾ç½®æ³µâ€ã€â€œåœæ­¢æ³µâ€ã€â€œå»¶æ—¶â€æ¥æ·»åŠ æ­¥éª¤åˆ°æµç¨‹åˆ—è¡¨ä¸­ã€‚
          * å¯ä»¥å¯¹åˆ—è¡¨ä¸­çš„æ­¥éª¤è¿›è¡Œåˆ é™¤ã€ä¸Šç§»ã€ä¸‹ç§»æ“ä½œã€‚
          * ç‚¹å‡» **â€œæ‰§è¡Œåè®®â€** æ¥è¿è¡Œæ•´ä¸ªè‡ªåŠ¨åŒ–æµç¨‹ã€‚
          * ä½¿ç”¨ **â€œä¿å­˜åˆ°æ–‡ä»¶...â€** å’Œ **â€œä»æ–‡ä»¶åŠ è½½...â€** æ¥å¤ç”¨æ‚¨çš„å®éªŒåè®®ã€‚

    <img src=image/ç”µæºç³»ç»Ÿç•Œé¢.png alt="ç”µæºç³»ç»Ÿç•Œé¢" style="zoom:50%" />

## ğŸ”§ å¦‚ä½•ä¿®æ”¹ä¸æ‰©å±•

### æ·»åŠ ä¸€ç§æ–°çš„è®¾å¤‡

æœ¬é¡¹ç›®çš„æ¨¡å—åŒ–è®¾è®¡è®©æ·»åŠ æ–°ç¡¬ä»¶å˜å¾—ç®€å•ã€‚å‡è®¾æ‚¨è¦æ·»åŠ ä¸€ç§æ–°çš„ "ABC ç‰Œ" æ³µï¼š

1.  **åˆ›å»ºæ§åˆ¶å™¨æ–‡ä»¶**: åœ¨é¡¹ç›®ä¸­æ–°å»ºä¸€ä¸ª `abc_pump_controller.py` æ–‡ä»¶ã€‚
2.  **ç»§æ‰¿åŸºç±»**: åœ¨æ–°æ–‡ä»¶ä¸­ï¼Œåˆ›å»ºä¸€ä¸ªç±» `ABCPump`ï¼Œè®©å®ƒç»§æ‰¿è‡ª `base_pump.py` ä¸­çš„ `BasePump` ç±»ã€‚
3.  **å®ç°æ¥å£**: æ‚¨å¿…é¡»å®ç° `BasePump` ç±»ä¸­å®šä¹‰çš„æ‰€æœ‰æ–¹æ³•ï¼Œå¦‚ `connect`, `disconnect`, `start`, `stop`, `set_parameters`, `get_status`ã€‚åœ¨è¿™äº›æ–¹æ³•å†…éƒ¨ï¼Œç¼–å†™é€šè¿‡ä¸²å£ï¼ˆæˆ–å…¶å®ƒæ–¹å¼ï¼‰ä¸ ABC æ³µé€šä¿¡çš„å®é™…ä»£ç ã€‚
4.  **æ³¨å†Œåˆ°å·¥å‚**: æ‰“å¼€ `system_controller.py` æ–‡ä»¶ï¼Œåœ¨ `device_factory` å‡½æ•°ä¸­ï¼Œæ·»åŠ ä¸€ä¸ªæ–°çš„ `elif` æ¡ä»¶ï¼š
    ```python
    # in system_controller.py -> device_factory()
    ...
    elif device_type == 'abc_pump':
        from abc_pump_controller import ABCPump # åˆ«å¿˜äº†å¯¼å…¥
        return ABCPump(port=config['port'], unit_address=config['address'])
    ...
    ```
5.  **æ›´æ–°é…ç½®**: ç°åœ¨ï¼Œæ‚¨å°±å¯ä»¥åœ¨ `system_config.json` ä¸­æ·»åŠ ä¸€ä¸ªæ–°è®¾å¤‡ï¼Œå¹¶å°†å…¶ `type` è®¾ç½®ä¸º `"abc_pump"`ã€‚ç¨‹åºå°†èƒ½è‡ªåŠ¨è¯†åˆ«å¹¶åˆ›å»ºå®ƒã€‚

-----

# English Version

# Automated Fluid Control System

This is an automated fluid control system designed for chemistry or materials science experiments. It provides a graphical user interface (GUI) for real-time monitoring and control of multiple peristaltic pumps, plunger pumps, and multi-channel DC power supplies, and supports automated experimental protocols.

 \#\# âœ¨ Features

  * **Graphical User Interface**: Built with PyQt6, intuitive and easy to use. Provides three window modes: a main launcher, a sub-system control panel, and an individual device debugger.
  * **Multi-Process Architecture**: The main UI and the device control backend run in separate processes. This ensures a smooth and responsive interface that won't freeze, even during intensive device communication.
  * **Real-time Data Monitoring**: Uses `pyqtgraph` to plot the status of each device (e.g., power supply voltage/current, pump speed/flow rate) in real-time.
  * **Automation Protocol**: Supports creating, editing, saving, and loading automated experimental workflows. You can combine a series of actions (start/stop pump, set parameters, delay) into a protocol and execute it with one click.
  * **Flexible Configuration System**:
      * All hardware configurations (COM ports, device addresses, etc.) are stored in an external `system_config.json` file, making it easy to adapt to different hardware setups without changing the code.
      * The launcher includes a built-in configuration editor to modify and save hardware parameters directly from the GUI.
  * **Modular Device Drivers**: Each device type has its own controller file, implemented based on a unified base class interface, making the system easy to maintain and extend.
  * **One-Click Packaging**: A `build.bat` script is provided to package the entire project into a standalone `.exe` executable using PyInstaller, allowing for easy deployment on any Windows computer.

## ğŸ“ System Architecture

The system employs a classic multi-process producer-consumer model to decouple the front-end UI from the back-end device control.

```
+--------------------------+      (multiprocessing.Queue)      +-----------------------------+
|     Main Process (UI)    |         Command & Status         |   Background Process (Controller) |
|        (main.py)         |                                  |   (system_controller.py)    |
|                          |                                  |                             |
| +----------------------+ |           [User Commands]        | +-------------------------+   |
| |  Launcher/Control  | |  ---------------------------->   | |     Command Processor   |   |
| |      Windows       | |                                  | | (Handles commands from UI)|
| +----------------------+ |           [Device Status]        | +-------------------------+   |
| |   Real-time Plots  | |  <----------------------------   | |      Status Poller      |   |
| |  (Data Visualization)| |                                  | | (Polls status from all) |
| +----------------------+ |                                  | +-------------------------+   |
|                          |                                  | |     Device Drivers      |   |
|                          |                                  | | (Communicate w/ hardware) |
|                          |                                  | +--+-----------+--------+   |
+--------------------------+                                  +----|---(PyVISA)---|--------+---+
                                                                   |              |
                                                              +----v----+    +-----v-----+
                                                              |  Power  |    |   Pumps   |
                                                              | Supply  |    |           |
                                                              +---------+    +-----------+
```

1.  **UI Process (`main.py`)**: Responsible for all user interactions. When a user clicks a button (e.g., "Start Pump"), it puts a command dictionary (e.g., `{'type': 'start_pump', 'params': ...}`) into the **Command Queue**. Concurrently, it continuously fetches the latest device data from the **Status Queue** to update plots and status labels.
2.  **Controller Process (`system_controller.py`)**:
      * Upon startup, it initializes and connects to all hardware devices based on the configuration.
      * In a main loop, it constantly checks the Command Queue. When a command is received, it invokes the appropriate device driver to perform the action (e.g., sending serial commands via `pymodbus` or `pyvisa`).
      * It periodically polls the current status of all devices (voltage, running state, etc.) and puts the aggregated status data into the Status Queue for the UI process to consume.

This design ensures that I/O-intensive hardware communication does not block the user interface.

## ğŸ“‚ File Structure

```
/
â”œâ”€â”€ main.py                     # Main application entry point, contains all window and UI logic
â”œâ”€â”€ system_controller.py        # Core backend logic for device control
â”œâ”€â”€ config.py                   # Logic for loading and saving configuration files
â”œâ”€â”€ system_config.json          # IMPORTANT: User hardware configuration file
â”œâ”€â”€ system_config.py            # Default hardware configuration (as a fallback)
|
â”œâ”€â”€ base_pump.py                # Abstract base class for pumps, defining a common interface
â”œâ”€â”€ kamoer_pump_controller.py   # Implementation for Kamoer peristaltic pumps
â”œâ”€â”€ plunger_pump_controller.py  # Implementation for Oushisheng plunger pumps
â”œâ”€â”€ power_supply_controller.py  # Implementation for GW Instek GPD-series power supplies
|
â”œâ”€â”€ requirements.txt            # List of project dependencies
â”œâ”€â”€ build.bat                   # Batch script for one-click packaging into an EXE
â”œâ”€â”€ build.spec                  # Configuration file for PyInstaller
â”œâ”€â”€ address.py                  # A standalone utility script to change pump Modbus addresses
â””â”€â”€ èµ„æºæŒ‡å—.md                 # A detailed guide on packaging (in Chinese)
```

## ğŸš€ How to Run

### 1\. Environment Setup

  * **Python**: Ensure you have Python 3.8 or newer installed.
  * **Clone the repository**: `git clone https://github.com/your-username/your-repo-name.git`
  * **Install Dependencies**: It's highly recommended to use a virtual environment.
    ```bash
    # Create and activate a virtual environment (optional but recommended)
    python -m venv venv
    source venv/bin/activate  # on Windows: venv\Scripts\activate
    
    # Install all required libraries
    pip install -r requirements.txt
    ```

### 2\. Hardware Configuration

This is the most crucial step.

1.  Open the `system_config.json` file.
2.  Modify the `port` and `address` for each device according to your actual hardware connections.
      * For the power supply, the `port` is typically a VISA resource name like `ASRL6::INSTR`.
      * For pumps, the `port` is the COM port name (e.g., `COM9`), and the `address` is its Modbus address.
      * Ensure that every device `id` is unique.

### 3\. Run from Source

After configuration is complete, run the main program from the project's root directory:

```bash
python main.py
```

The application will start with a launcher window, from which you can open control panels or debug individual devices.

### 4\. Run as a Packaged EXE

If you want to run the application on a computer without a Python environment, you can package it into an `.exe` file.

1.  Make sure `build.bat` and `build.spec` are in the project root directory.
2.  **Double Click `build.bat` script**.
3.  The script will automatically install `pyinstaller` and execute the packaging process.
4.  Wait for the process to finish. Upon success, a `dist` folder will appear in your project directory.
5.  Navigate into the `dist` folder and find `æ§åˆ¶ç³»ç»Ÿ.exe`. This is your standalone application. Double-click to run.


## ğŸ“– How to Use

1. **Launcher**:

     * The launcher window appears on startup.
     * Click a **"Launch Control Power System X"** button to open the full control interface for that system.
     * Click **"Debug a Single Device"** to select one device (like a specific pump or the power supply) and open a dedicated debugging window for isolated testing.
     * Expand the **"Hardware Configuration"** panel to modify device ports and addresses directly. Click the **"Save All Configurations"** button in the bottom-right corner to write your changes to `system_config.json`.

   <img src=image/ä¸»ç•Œé¢.png alt="ä¸»ç•Œé¢" style="zoom:40%" />

   

2. **System Control Window**:

     * The interface is split into two sub-systems (A and B), corresponding to the two channels of the power supply.
     * **Power Control**: Set the target voltage and current, and toggle the output for each channel. A timed-off feature is available.
     * **Pump Control**: For each pump, set its parameters (speed/flow rate), direction, and start/stop it individually.
     * **Real-time Charts**: The plots at the bottom display voltage, current, and pump parameters in real-time. You can export the chart as a PNG image or export the data as an Excel file.
     * **Protocol Editor**:
         * Click "Start/Set Pump", "Stop Pump", or "Add Delay" to add steps to the workflow list.
         * You can select steps in the list to remove them or move them up/down.
         * Click **"Run Protocol"** to execute the entire automated sequence.
         * Use **"Save to File..."** and **"Load from File..."** to reuse your experimental protocols.

   <img src=image/ç”µæºç³»ç»Ÿç•Œé¢.png alt="ç”µæºç³»ç»Ÿç•Œé¢" style="zoom:40%" />

## ğŸ”§ How to Modify and Extend

### Adding a New Device

The project's modular design makes it straightforward to add new hardware. For example, to add a new "ABC" brand pump:

1.  **Create a Controller File**: Create a new file named `abc_pump_controller.py` in the project.
2.  **Inherit from the Base Class**: In the new file, create a class `ABCPump` that inherits from the `BasePump` class in `base_pump.py`.
3.  **Implement the Interface**: You must implement all methods defined in the `BasePump` interface, such as `connect`, `disconnect`, `start`, `stop`, `set_parameters`, and `get_status`. Inside these methods, write the actual code to communicate with the ABC pump via serial (or other protocols).
4.  **Register in the Factory**: Open `system_controller.py` and, within the `device_factory` function, add a new `elif` condition:
    ```python
    # in system_controller.py -> device_factory()
    ...
    elif device_type == 'abc_pump':
        from abc_pump_controller import ABCPump # Don't forget to import
        return ABCPump(port=config['port'], unit_address=config['address'])
    ...
    ```
5.  **Update Configuration**: You can now add a new device in `system_config.json` and set its `type` to `"abc_pump"`. The program will now be able to recognize and create it.